"""
Conversation Memory Manager - Main Interface for RL System
Orchestrates embedding generation, storage, and retrieval
This is the Facade that agents will interact with
"""

import logging
from typing import List, Dict, Optional
from uuid import UUID, uuid4
from clera_agents.reinforcement_learning import (
    IMemoryManager,
    IEmbeddingProvider,
    IMemoryStore,
    ConversationExperience,
    SimilarExperience,
    MemoryStats
)
from clera_agents.reinforcement_learning.embedding_provider import OpenAIEmbeddingProvider
from clera_agents.reinforcement_learning.memory_store import SupabaseMemoryStore

logger = logging.getLogger(__name__)


class ConversationMemoryManager(IMemoryManager):
    """
    High-level memory manager for conversation experiences.
    Implements the RL experience replay and reward-based learning system.
    
    This class follows the Facade pattern, providing a simple interface
    while orchestrating complex operations behind the scenes.
    """
    
    def __init__(
        self,
        embedding_provider: IEmbeddingProvider = None,
        memory_store: IMemoryStore = None
    ):
        """
        Initialize memory manager with dependency injection.
        
        Args:
            embedding_provider: Provider for generating embeddings (defaults to OpenAI)
            memory_store: Store for persisting memories (defaults to Supabase)
        """
        self.embedding_provider = embedding_provider or OpenAIEmbeddingProvider()
        self.memory_store = memory_store or SupabaseMemoryStore()
        logger.info("Initialized ConversationMemoryManager")
    
    def store_interaction(
        self,
        user_id: str,
        thread_id: str,
        query_text: str,
        agent_response: str,
        agent_type: str,
        context_snapshot: Dict = None
    ) -> UUID:
        """
        Store a new conversation interaction.
        This is the first step in the RL loop: recording an experience.
        
        Args:
            user_id: ID of the user
            thread_id: ID of the conversation thread
            query_text: User's query
            agent_response: Agent's response
            agent_type: Type of agent that responded
            context_snapshot: Optional context (market data, portfolio state, etc.)
            
        Returns:
            UUID of the stored experience
            
        Raises:
            ValueError: If required parameters are invalid
            Exception: If storage fails
        """
        # Validate inputs
        if not user_id or not user_id.strip():
            raise ValueError("user_id cannot be empty")
        if not thread_id or not thread_id.strip():
            raise ValueError("thread_id cannot be empty")
        if not query_text or not query_text.strip():
            raise ValueError("query_text cannot be empty")
        if not agent_response or not agent_response.strip():
            raise ValueError("agent_response cannot be empty")
        
        try:
            # Create experience object
            experience = ConversationExperience(
                id=None,  # Will be generated by database
                user_id=user_id,
                thread_id=thread_id,
                query_text=query_text,
                agent_response=agent_response,
                agent_type=agent_type,
                context_snapshot=context_snapshot or {},
                feedback_score=0,  # Neutral until user provides feedback
                outcome_score=None  # Will be updated later with delayed reward
            )
            
            # Generate embedding for query
            logger.debug(f"Generating embedding for query: {query_text[:50]}...")
            embedding = self.embedding_provider.get_embedding(query_text)
            
            # Store in database
            experience_id = self.memory_store.store_experience(experience, embedding)
            
            logger.info(f"Stored interaction {experience_id} for user {user_id}")
            return experience_id
            
        except Exception as e:
            logger.error(f"Failed to store interaction: {e}")
            raise
    
    def retrieve_relevant_memories(
        self,
        query_text: str,
        user_id: str,
        agent_type: Optional[str] = None,
        top_k: int = 3,
        min_feedback_score: int = 0
    ) -> List[SimilarExperience]:
        """
        Retrieve relevant past experiences for a query.
        This implements the EXPERIENCE REPLAY mechanism in RL.
        
        The system retrieves similar past interactions that received positive
        feedback, allowing agents to learn from successful patterns.
        
        Args:
            query_text: Current query to find similar experiences for
            user_id: User ID to retrieve experiences for
            agent_type: Optional filter for specific agent type
            top_k: Number of similar experiences to retrieve
            min_feedback_score: Minimum feedback score (reward threshold)
                              0 = neutral or positive, 1 = only positive
            
        Returns:
            List of SimilarExperience objects, ordered by reward then similarity
        """
        # Validate inputs
        if not query_text or not query_text.strip():
            raise ValueError("query_text cannot be empty")
        if not user_id or not user_id.strip():
            raise ValueError("user_id cannot be empty")
        if top_k < 1:
            raise ValueError("top_k must be at least 1")
        
        try:
            # Generate embedding for query
            logger.debug(f"Generating embedding for query: {query_text[:50]}...")
            query_embedding = self.embedding_provider.get_embedding(query_text)
            
            # Retrieve similar experiences from store
            similar_experiences = self.memory_store.retrieve_similar(
                query_embedding=query_embedding,
                user_id=user_id,
                agent_type=agent_type,
                top_k=top_k,
                min_feedback_score=min_feedback_score,
                similarity_threshold=0.7  # Cosine similarity threshold
            )
            
            if similar_experiences:
                logger.info(
                    f"Retrieved {len(similar_experiences)} relevant memories for user {user_id}. "
                    f"Avg similarity: {sum(exp.similarity for exp in similar_experiences) / len(similar_experiences):.3f}"
                )
            else:
                logger.debug(f"No relevant memories found for user {user_id}")
            
            return similar_experiences
            
        except Exception as e:
            logger.error(f"Failed to retrieve relevant memories: {e}")
            # Don't fail - return empty list to allow system to continue
            return []
    
    def record_feedback(self, experience_id: UUID, is_positive: bool):
        """
        Record user feedback on an experience.
        This provides the REWARD SIGNAL in the RL system.
        
        Args:
            experience_id: ID of the experience to update
            is_positive: True for thumbs up (+1), False for thumbs down (-1)
        """
        try:
            feedback_score = 1 if is_positive else -1
            self.memory_store.update_feedback(experience_id, feedback_score)
            logger.info(f"Recorded {'positive' if is_positive else 'negative'} feedback for experience {experience_id}")
            
        except Exception as e:
            logger.error(f"Failed to record feedback: {e}")
            raise
    
    def get_user_stats(self, user_id: str) -> MemoryStats:
        """
        Get statistics about user's memory bank.
        Used for evaluation and monitoring.
        
        Args:
            user_id: User ID to get stats for
            
        Returns:
            MemoryStats object with comprehensive statistics
        """
        try:
            stats = self.memory_store.get_stats(user_id)
            logger.debug(f"Retrieved stats for user {user_id}: {stats.total_experiences} experiences")
            return stats
            
        except Exception as e:
            logger.error(f"Failed to get user stats: {e}")
            raise
    
    def log_memory_retrieval(
        self,
        query_id: UUID,
        retrieved_experiences: List[SimilarExperience]
    ):
        """
        Log a memory retrieval for evaluation purposes.
        Helps analyze retrieval quality and relevance.
        
        Args:
            query_id: ID of the query experience
            retrieved_experiences: List of experiences that were retrieved
        """
        if not retrieved_experiences:
            return
        
        try:
            retrieved_ids = [exp.experience.id for exp in retrieved_experiences]
            scores = [exp.similarity for exp in retrieved_experiences]
            ranks = list(range(1, len(retrieved_experiences) + 1))
            
            self.memory_store.log_retrieval(query_id, retrieved_ids, scores, ranks)
            
        except Exception as e:
            # Don't fail - logging is for evaluation only
            logger.warning(f"Failed to log retrieval: {e}")


# Factory function for easy instantiation
def create_memory_manager() -> ConversationMemoryManager:
    """
    Factory function to create a ConversationMemoryManager with default dependencies.
    Use this in production code for consistency.
    """
    return ConversationMemoryManager()

